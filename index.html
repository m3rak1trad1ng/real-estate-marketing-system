<script>
  (function(){
    // FAQ: only one open at a time
    const allFaq = Array.from(document.querySelectorAll('#faq details'));
    allFaq.forEach(d => {
      d.addEventListener('toggle', () => {
        if (!d.open) return;
        allFaq.forEach(other => { if (other !== d) other.open = false; });
      });
    });

    const topbar = document.getElementById('topbar');
    const topbarInner = document.getElementById('topbar-inner');

    // Measure sticky nav height and store in CSS var (use TOPBAR, not inner)
    function getTopbarH(){
      if (!topbar) return 52;
      return Math.ceil(topbar.getBoundingClientRect().height);
    }
    function setTopbarH(){
      const h = getTopbarH();
      document.documentElement.style.setProperty('--topbarH', h + 'px');
      return h;
    }

    setTopbarH();
    requestAnimationFrame(setTopbarH);
    window.addEventListener('load', setTopbarH);
    window.addEventListener('resize', setTopbarH);

    // CONSISTENT anchor landing: always scroll to the section's H2 (not section top)
    function scrollToHash(hash, pushState){
      const id = (hash || "").replace('#','');
      if (!id) return;

      const section = document.getElementById(id);
      if (!section) return;

      const heading = section.querySelector('h2') || section;

      // re-measure immediately before scrolling (fixes FAQ mismatch)
      const topbarH = setTopbarH();

      // anchor gap from CSS var (fallback 14)
      const gapRaw = getComputedStyle(document.documentElement).getPropertyValue('--anchorGap');
      const gap = parseInt(gapRaw, 10);
      const anchorGap = Number.isFinite(gap) ? gap : 14;

      const y = heading.getBoundingClientRect().top + window.pageYOffset - (topbarH + anchorGap);

      const prefersReduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      window.scrollTo({ top: Math.max(0, y), behavior: prefersReduced ? 'auto' : 'smooth' });

      if (pushState) history.pushState(null, '', '#' + id);
    }

    // Intercept nav clicks (so all anchors land the same)
    const nav = document.getElementById('nav');
    if (nav){
      nav.addEventListener('click', (e) => {
        const a = e.target.closest('a[href^="#"]');
        if (!a) return;
        e.preventDefault();
        scrollToHash(a.getAttribute('href'), true);
      });
    }

    // If page loads with a hash, scroll to it with offset
    if (location.hash){
      setTimeout(() => scrollToHash(location.hash, false), 0);
    }

    // Back/forward
    window.addEventListener('popstate', () => {
      if (location.hash) scrollToHash(location.hash, false);
    });

    // Scrollspy active nav link
    const navLinks = Array.from(document.querySelectorAll('.nav a'));
    const sections = navLinks
      .map(a => document.querySelector(a.getAttribute('href')))
      .filter(Boolean);

    const linkById = new Map(navLinks.map(a => [a.getAttribute('href').slice(1), a]));

    const obs = new IntersectionObserver((entries) => {
      const visible = entries
        .filter(e => e.isIntersecting)
        .sort((a,b) => (b.intersectionRatio - a.intersectionRatio))[0];
      if (!visible) return;

      navLinks.forEach(a => a.classList.remove('active'));
      const link = linkById.get(visible.target.id);
      if (link) link.classList.add('active');
    }, {
      root: null,
      rootMargin: `-${getTopbarH()}px 0px -55% 0px`,
      threshold: [0.15, 0.25, 0.35, 0.5]
    });

    sections.forEach(s => obs.observe(s));
  })();
</script>
